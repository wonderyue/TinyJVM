import functools
# import threading


def unsafe_singleton(cls):
    cls.__new_original__ = cls.__new__

    @functools.wraps(cls.__new__)
    def singleton_new(cls, *args, **kwargs):
        it = cls.__dict__.get('__it__')
        if it is not None:
            return it

        cls.__it__ = it = cls.__new_original__(cls, *args, **kwargs)
        it.__init_original__(*args, **kwargs)
        return it

    cls.__new__ = singleton_new
    cls.__init_original__ = cls.__init__
    cls.__init__ = object.__init__
    return cls


# def singleton(cls):
#     cls.__new_original__ = cls.__new__
#     @functools.wraps(cls.__new__)
#     def singleton_new(cls, *args, **kwargs):
#         with threading.Lock():
#             it = cls.__dict__.get('__it__')
#             if it is not None:
#                 return it

#             cls.__it__ = it = cls.__new_original__(cls, *args, **kwargs)
#             it.__init_original__(*args, **kwargs)
#             return it

#     cls.__new__ = singleton_new
#     cls.__init_original__ = cls.__init__
#     cls.__init__ = object.__init__
#     return cls
